# ~~Растр, нет, блин,~~ (Шестая домашка)

**Данная домашка состоит только из одной части, обязательной для всех групп!**

## Что надо делать

Вам необходимо реализовать шаблонный вектор, который чем-то очень похож на тот, который встроен в C++.

У вашего вектора должен быть **один шаблонный тип-аргумент**, обозначающий тип, который будет храниться в внутри контейнера.

### Capacity и саморасширяемость

Наш вектор будет **только саморасширяющимся, но не будет самосуживающимся**, иными словами, если в векторе кончилось место, то он расширится до, как минимум,
необходимого размера. Но при этом при удалении элементов из вектора, сужать мы его не будем!

#### Как это вообще работает?

Наш вектор будет содержать в себе 3 сущности:

1) `capacity` -- размер внутреннего массива
2) `arr` -- указатель на внутренний массив размера `capacity`
3) `pos` -- номер первой незанятой ячейки в `arr` (изначально, очевидно, `0`)

Иными словами, вектор выделяет некоторый массив, который постепенно заполняется (увеличивается `pos`) при работе с вектором, а когда этот массив (`arr`) будет
заполнен полностью (`pos == capacity`), то вектор должен выделить новый массив, большей длинны и переложить в него все элементы из старого массива, старый
массив корректно удалить и сделать так, чтобы `arr` указывал на новый массив. (Надо не забыть поменять `capacity`, а `pos` оставить неизменным)

Если каждый раз умножать размер внутреннего массива (`capacity`) на какое-то фиксированное число (экспоненциальный рост `capacity`), то можно доказать, что,
суммарное количество действий, затрачиваемых на релокации будет линейно зависеть от количества элементов в векторе, таким образом, средний оверхед на релокации
будет константным, а значит "маленьким"!

Обратите внимание, что `capacity` и `pos` это разные сущности -- первая показывает какого размера внутреннее хранилище нашего вектора, а вторая -- насколько оно
заполнено (удобно, чтобы `pos` было индексом первой незанятой ячейки в `arr`, подумайте почему).

#### Как выглядит capacity?

В нашей реализации `capacity` должна быть **ВСЕГДА СТЕПЕНЬЮ ДВОЙКИ ИЛИ НУЛЕМ!!!**

Каждый раз, когда вы понимаете, что `capacity` слишком мало, чтобы вместить новые добавляемые элементы, то вам **необходимо выбрать минимальную степень двойки,
большую, либо равную** суммарному количеству элементов в векторе после изменений. Иными словами, если в векторе было 5 элементов, а `capacity` равно 8 и вы
хотите добавить 100 элементов, то после изменения в векторе будет 105 элементов и `capacity` должна быть равна 128 (ближайшая большая, либо равная степень
двойки)

**При удалении** `capacity` **не должна уменьшаться!** Это и значит, что **наш вектор не самосуживающийся!!!** Для уменьшения `capacity` будет отдельный ручной
метод.

Кстати в векторе, который встроен в C++ применена такая же парадигма, что расширяется вектор сам, а вот сужается только если его явно об этом попросить. Сделано
это для того чтобы уменьшить количество аллокаций памяти и перемещений элементов из одного хранилища в другое. Очевидно, что когда кончается место, то
необходимо выделить новый кусок памяти большего размера и все переложить в него, а вот при сужении в этом острой необходимости нет, только если вам важно, чтобы
вектора потребляли количество памяти, соизмеримое с количеством хранимых в нем элементов, чтобы этого добиться вам достаточно вызвать определенный метод!

### Необходимый функционал

1) Конструктор без аргументов -- `capacity` должно быть `0`, `pos` должно быть `0`, `arr` должно быть `nullptr`
2) Fill-конструктор -- принимает два аргумента: количество элементов (`size_t`) и чем заполнить (`const T &`) (по аналогии с третьим конструктором `std::vector`
   на cppreference.com), при этом у второго аргумента должно быть дефолтное значение аргумента -- объект созданный пустыми круглыми скобками (`= T()`), чтобы
   этот конструктор можно было вызвать от одного аргумента -- только количества. **Если количество равно** `0`, **то поведение конструктора должно в точности
   повторить поведение конструктора без аргументов**, в противном случае, `pos` должен быть равен `0`, `capacity` -- ближайшей большей, либо равной степени
   двойки (к количеству элементов), `arr` указатель на массив размера `capacity`
3) Конструктор копирования -- (копирует `other`) должен скопировать `pos`, а вот `capacity` должен быть снова минимальной большей, либо равной степенью двойки (
   по отношению к `pos`, а если `pos == 0`, **то созданный вектор должен быть таким же как вектор, созданный конструктором без аргументов**), также обратите
   внимание, что просто скопировать указатель `arr` -- некорректное поведение, потому что тогда у физически разных векторов будет общее хранилище, поэтому надо
   выделить свой массив и скопировать в него первые `other.pos` элементов из `other.arr`, и поэтому этот конструктор не может быть `= default`
4) Оператор присвоения (copy-assignment) -- должен быть реализован через swap-trick и повторить поведение для конструктора копирования (что получится само
   собой, если вы будете использовать swap-trick). Прелесть swap-trick-а в том, что вам не придется дублировать руками логику конструктора копирования, а так
   же, будет автоматическая чистка старых ресурсов без опасности самоудаления при присвоении объекта самому себе!
5) Деструктор, который должен правильным образом освободить все ресурсы, которые использовал ваш вектор
6) Оператор квадратные скобки (`operator[]`) который должен принимать индекс элемента и возвращать ссылку на этот элемент из вектора. Обратите внимание, что
   придется сделать две реализации этого оператора -- константную (которая будет вызываться у константного вектора и возвращать константную ссылку на элемент и
   неконстантную, которая будет вызываться у неконстантного вектора и будет возвращать неконстантную ссылку -- перегрузка методов по консту). Никаких проверок
   на выходы за границы массива делать не надо, считаем, что часть интерфейса состоит в том, что у нас не будут запрашивать несуществующие элементы
7) Метод `front`, который возвращает ссылку на первый (нулевой) элемент вектора. Во всем должен повторять `operator[]`, кроме того, что не принимает индекс, а
   всегда возвращает первый (нулевой) элемент. Так же надо две реализации и так же не надо проверок на то что элемент существует
8) Метод `back`, который возвращает ссылку на последний элемент вектора. Во всем должен повторять `operator[]`, кроме того, что не принимает индекс, а всегда
   возвращает последний элемент. Так же надо две реализации и так же не надо проверок на то что элемент существует
9) Метод `data` должен возвращать указатель на внутреннее хранилище. Так же надо две реализации. В константном случае должен возвращать указатель на
   неизменяемые элементы (вспоминаем где и зачем надо писать консты у указателей)
10) Метод `empty` должен возвращать `bool`, правда ли, что вектор пуст
11) Метод `size` должен возвращать количество элементов в векторе
12) Метод `reserve` принимает новое минимальное необходимое `capacity` -- `new_cap`. Метод нужен для того, чтобы пользователь мог влиять на `capacity`.
    Результатом работы этого метода должно стать то, что `capacity` вектора должно стать хотя бы `new_cap`. **Если** `capacity >= new_cap`**, то метод не должен
    ничего делать!** В противном случае `capacity` должно стать минимальной большей, либо равной степенью двойки (для `new_cap`), ну и надо будет выделить новое
    хранилище и переложить все элементы в него
13) Метод `capacity` должен возвращать `capacity` вашего вектора (обратите внимание, что **называть поля и методы одним именем нельзя**)
14) Метод `shrink_to_fit` сужает `capacity` насколько может, чтобы `capacity` вмещало все элементы, а так же было степенью двойки. То есть если можно сузить
    хранилище, то надо выделить новое хранилище меньшего размера и все в него переложить. В случае если вектор был пуст, то после работы этого метода вектор
    должен стать таким же как вектор, созданный конструктором без аргументов. Если же сужать некуда, то метод не должен ничего делать
15) Метод `clear` должен сделать ваш вектор таким же как вектор, созданный конструктором без аргументов
16) Метод `insert` должен иметь две перегрузки:
    * Принимает позицию (`size_t`) **ПЕРЕД КОТОРОЙ НАДО ВСТАВИТЬ** и значение (`const T &`), которое надо вставить. Все элементы на позициях, больше либо равных
      переданной, необходимо сдвинуть на 1 элемент вправо, чтобы освободить место под вставляемый элемент, при необходимости вектор должен быть расширен.
      Обратите внимание, что позиция для вставки может принимать все значения от `0`, до размера вектора включительно. При `0` надо вставить перед первым (
      нулевым) элементом вектора (в самое начало), а при размере вектора надо вставить после последнего (с учетом 0-индексации это вполне разумное действие,
      потому что у вас `size()` элементов с номерами от `0` до `size() - 1`, а вот мест для вставки `size() + 1`, занумерованных от `0` до `size()`). **Проверку
      выхода за границы массива вам делать не надо!**
    * Принимает позицию (`size_t`) **ПЕРЕД КОТОРОЙ НАДО ВСТАВИТЬ**, количество (`size_t`) и значение (`const T &`), которе надо вставить. Действует как первая
      перегрузка метода `insert`, только вставляет не один элемент, а столько копий аргумента-значения, сколько было сказано в аргументе-количестве. Обратите
      внимание, что **потенциально придется расширить больше чем в два раза**
17) Метод `erase` должен иметь две перегрузки:
    * Принимает позицию (`size_t`) (в 0-индексации) элемента, который надо удалить, соответственно все элементы, с индексами большими, чем переданный, надо
      сдвинуть на 1 влево, чтобы закрыть дырку от удаленного элемента. `capacity` **меняться не должно!** Позиция принимает значения от `0` до `size() - 1`. **
      Проверку выхода за границы массива вам делать не надо!**
    * Принимает полуинтервал (`size_t first, size_t last`) позиций для удаления элементов, иными словами должен удалять все элементы с индексами в
      полуинтервале `[first, last)`. Действует аналогично первой перегрузке, только удаляет не один а несколько (потенциально 0), подряд идущих, элементов.
      Гарантируется, что `0 <= first <= last <= size()`
      -- обратите внимание, что **все три знака нестрогие**! Если `first == last`, то это пустой полуинтервал и ничего удалять не надо. `capacity` **меняться не
      должно!** **Проверку выхода за границы массива вам делать не надо!**
18) Метод `push_back` должен принимать значение (`const T &`) и должен вставлять его после последнего элемента вектора. При необходимости, вектор должен быть
    расширен
19) Метод `pop_back` должен удалить последний элемент в векторе. `capacity` **меняться не должно!** Проверок на наличие хотя бы одного элемента делать не надо!
20) Метод `resize` принимает два аргумента -- новый размер (`size_t new_size`) и чем заполнить при расширении (`const T &val = T()`), с дефолтным значением
    второго аргумента, как это было в fill-конструкторе. Этот метод делает так, чтобы **размер** вектора было в точности `new_size`.
    * Если `size() >= new_size`, то надо удалить с конца столько элементов, чтобы `size()` стал равен `new_size`, при этом `capacity` не должно поменяться!
    * В противном случае добавить в конец столько элементов, равных `val`, чтобы `size()` стал равен `new_size`, при необходимости вектор должен быть расширен!
21) Метод `swap` должен принимать другой вектор по ссылке и обменивать себя и этот другой вектор содержимым. При этом никаких аллокаций и никаких копирований
    элементов не должно происходить! При этом `capacity` надо просто перенять от другого вектора, не пытаться его сужать, как в конструкторе копирования и
    операторе копирования
22) Операторы сравнения (все 6), сравнение должно происходить в лексикографическом порядке

Хочу еще добавить пару слов, многие методы можно реализовать через другие методы -- постарайтесь делать так как можно чаще, чтобы не дублировать логику между
методами, что значительно упростит разработку!!!

## Что можно менять

Файл `vector.h`. В нем должен быть единственный шаблонный класс `vector_t` параметризованный типом `T` хранимых в нем элементов. **Больше никакие файлы вам не
надо менять.**

## Тестирование

Чтобы собрать и запустить тесты в медленном дебаг режиме без проверок скорости надо выполнить:

`python3 scripts/run-tests.py`

или

`python3 scripts/run-tests.py -c Debug`

Некоторые тесты достаточно нагруженные и частью задания является укладывание времени работы вашего вектора в очерченный лимит в **полсекунды на тест**.

Чтобы запустить тесты с проверкой скорости надо выполнить:

`python3 scripts/run-tests.py -c Release`

Чтобы запустить тесты с проверкой на "утечки памяти" и выходы за границы массивов, но без проверки скорости надо выполнить:

`python3 scripts/run-tests.py -c RelWithDebInfo`

Если вы хотите узнать сколько работает ваша программа, но ее рубят по таймауту, то вы можете запустить тесты с повышенным таймаутом (при этом таймаут в
тестирующей системе не изменится). Для этого вам надо:

`python3 scripts/run-tests.py -c Release --timeout 100000`

Если у вас падает какой-то конкретный тест и вы хотите запускать только его, то вы можете открыть файл `main.cpp` в **CLion**. Найти этот тест в коде и нажать
на зеленый треугольничек слева от декларации теста. Единственный минус такого запуска в том, что не будут проверены таймауты.

Чтобы запускать только один тест с проверкой таймаута вам надо:

`python3 scripts/run-tests.py -c Release --filter Vector.PushBackStress`

(тут `Vector.PushBackStress` -- имя теста, который вы хотите запустить)

Также можно добавить опцию `--timeout 100000` чтобы запустить на одном тесте с повышенным таймаутом
